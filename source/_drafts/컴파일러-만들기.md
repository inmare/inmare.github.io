---
title: 컴파일러 만들기
categories: [Computer-Science]
tags: [computer-science, compiler, javascript]
---

이 [튜토리얼](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)의 번역글

- [최종 결과물](#최종-결과물)
- [컴파일러의 구조](#컴파일러의-구조)
- [Parsing](#parsing)
  - [예시](#예시)
- [Transformation](#transformation)

# 최종 결과물

아래와 같은 LISP와 같은 언어 구문을 C와 같은 언어 구문으로 변환하는 컴파일러를 만든다.

|             | LISP                   | C                      |
| ----------- | ---------------------- | ---------------------- |
| 2 + 2       | (add 2 2)              | add(2, 2)              |
| 4 - 2       | (subtract 4 2)         | subtract(4, 2)         |
| 2 + (4 - 2) | (add 2 (subtract 4 2)) | add(2, subtract(4, 2)) |

# 컴파일러의 구조

대부분의 컴파일러는 아래와 같은 3단계의 구조를 가진다.

1. **Parsing**: 코드를 읽고 더 추상적인 형태로 만든다.
2. **Transformation**: 추상적인 구문을 읽고 컴파일러가 원하는 형태로 조작한다.
3. **Code generation**: 조작된 구문을 읽고 새로운 코드로 변환한다.

# Parsing

Parsing은 아래의 두단계로 나뉘어진다.

1. **Lexical Analysis**: 소스 코드를 읽고 해당 코드를 token이라는 것들로 나눈다. 이때 해당 과정에는 tokenizer나 lexer를 사용한다.
2. **Syntatic Analysis**: Token을 읽고 해당 토큰을 각 부분의 문법이나, 다른 요소들과의 관계를 나타내는 형태로 변형한다. 이 과정은 intermediate representation이나 Abstract Syntax Tree라고 불린다.

이때 Abstract Syntax Tree(AST)는 깊게 중첩된 구조로, 우리에게 코드에 대한 정보를 알려주고 작업을 용이하게 만든다.

## 예시

아래의 문법을 token으로 나누면 아래와 같다.

```
(add 2 subtract(4 2))
```

```
// Token
[
    { type: 'paren',  value: '('        },
    { type: 'name',   value: 'add'      },
    { type: 'number,  value: '2'        },
    { type: 'paren',  value: '('        },
    { type: 'name',   value: 'subtract' },
    { type: 'number', value: '4'        },
    { type: 'number', value: '2'        },
    { type: 'paren',  value: ')'        },
    { type: 'paren',  value: ')'        }
]
```

그리고 이를 AST로 변환하면 아래와 같은 느낌이다.

```
// AST
{
    type: 'Program',
    body: [{
        type: 'CallExpression',
        name: 'add',
        params: [{
            type: 'NumberLiteral',
            value: '2,
        }, {
            type: 'CallExpression',
            name: 'subtract',
            params: [{
                type: 'NumberLiteral',
                valeu: '4',
            }, {
                type: 'NumberLiteral',
                value: '2',
            }]
        }]
    }]
}
```

# Transformation

이 과정에서는 AST를 읽고 다른 형식으로 변환하는 작업을 수행한다.  
이는 같은 언어로의 변환일 수 있고, 다른 언어로의 변환일 수도 있다.

그리고 AST의 내부에는 구조가 비슷한 요소들이 들어가 있는데, 이 요소들을 AST Node라고 부른다. 이 node들은 트리의 각 부분에 대한 설명을 담고 있다.

예를 들어, 위의 코드에서 `NumberLiteral` node는 아래와 같은 정보를 담고 있다.

```
{
    type: 'NumberLiteral',
    value: '2'
}
```

그리고 `CallExpression` node는 아래와 같은 정보를 담고 있다.

```
{
    type: 'CallExpression',
    name: 'add',
    params: [...중첩된 node들...]
}
```
