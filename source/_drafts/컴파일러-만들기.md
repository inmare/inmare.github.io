---
title: 컴파일러 만들기
categories: [CS관련]
tags: [computer-science, compiler, javascript]
---

이 [튜토리얼](https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js)의 번역글

- [최종 결과물](#최종-결과물)
- [컴파일러의 구조](#컴파일러의-구조)
- [Parsing](#parsing)
  - [예시](#예시)
- [Transformation](#transformation)
  - [Traversal](#traversal)
  - [Visitor](#visitor)
- [Code generation](#code-generation)
- [실제로 적용하기](#실제로-적용하기)
  - [Tokenizer](#tokenizer)

# 최종 결과물

아래와 같은 LISP와 같은 언어 구문을 C와 같은 언어 구문으로 변환하는 컴파일러를 만든다.

|             | LISP                   | C                      |
| ----------- | ---------------------- | ---------------------- |
| 2 + 2       | (add 2 2)              | add(2, 2)              |
| 4 - 2       | (subtract 4 2)         | subtract(4, 2)         |
| 2 + (4 - 2) | (add 2 (subtract 4 2)) | add(2, subtract(4, 2)) |

# 컴파일러의 구조

대부분의 컴파일러는 아래와 같은 3단계의 구조를 가진다.

1. **Parsing**: 코드를 읽고 더 추상적인 형태로 만든다.
2. **Transformation**: 추상적인 구문을 읽고 컴파일러가 원하는 형태로 조작한다.
3. **Code generation**: 조작된 구문을 읽고 새로운 코드로 변환한다.

# Parsing

Parsing은 아래의 두단계로 나뉘어진다.

1. **Lexical Analysis**: 소스 코드를 읽고 해당 코드를 token이라는 것들로 나눈다. 이때 해당 과정에는 tokenizer나 lexer를 사용한다.
2. **Syntatic Analysis**: Token을 읽고 해당 토큰을 각 부분의 문법이나, 다른 요소들과의 관계를 나타내는 형태로 변형한다. 이 과정은 intermediate representation이나 Abstract Syntax Tree라고 불린다.

이때 Abstract Syntax Tree(AST)는 깊게 중첩된 구조로, 우리에게 코드에 대한 정보를 알려주고 작업을 용이하게 만든다.

## 예시

아래의 문법을 token으로 나누면 아래와 같다.

```
(add 2 subtract(4 2))
```

```
// Token
[
    { type: 'paren',  value: '('        },
    { type: 'name',   value: 'add'      },
    { type: 'number,  value: '2'        },
    { type: 'paren',  value: '('        },
    { type: 'name',   value: 'subtract' },
    { type: 'number', value: '4'        },
    { type: 'number', value: '2'        },
    { type: 'paren',  value: ')'        },
    { type: 'paren',  value: ')'        }
]
```

그리고 이를 AST로 변환하면 아래와 같은 느낌이다.

```
// AST
{
    type: 'Program',
    body: [{
        type: 'CallExpression',
        name: 'add',
        params: [{
            type: 'NumberLiteral',
            value: '2,
        }, {
            type: 'CallExpression',
            name: 'subtract',
            params: [{
                type: 'NumberLiteral',
                valeu: '4',
            }, {
                type: 'NumberLiteral',
                value: '2',
            }]
        }]
    }]
}
```

# Transformation

이 과정에서는 AST를 읽고 다른 형식으로 변환하는 작업을 수행한다.  
이는 같은 언어로의 변환일 수 있고, 다른 언어로의 변환일 수도 있다.

그리고 AST의 내부에는 구조가 비슷한 요소들이 들어가 있는데, 이 요소들을 AST Node라고 부른다. 이 node들은 트리의 각 부분에 대한 설명을 담고 있다.

예를 들어, 위의 코드에서 `NumberLiteral` node는 아래와 같은 정보를 담고 있다.

```
{
    type: 'NumberLiteral',
    value: '2'
}
```

그리고 `CallExpression` node는 아래와 같은 정보를 담고 있다.

```
{
    type: 'CallExpression',
    name: 'add',
    params: [...중첩된 node들...]
}
```

AST를 transforming하는 과정은 node를 더하거나, 제거하거나, 대체하는 작업을 포함한다.  
다만 이 글에서는 완전히 새로운 언어로 변환하기에 기존의 tree를 두고 새로운 tree를 만든다.

## Traversal

모든 노드를 순회하는 작업을 traversal이라고 한다.
이때 위의 예시를 순회하면 아래와 같은 순서로 순회하게 된다.

1. `Program`: 가장 위의 node부터 시작한다.
2. `CallExpression`: `Program`의 body에 있는 첫번째 node를 순회한다.
3. `NumberLiteral (2)`: `CallExpression`의 param중 첫번째 요소로 이동한다.
4. `CallExpression (subtract)`: `CallExpression`의 param중 두번째 요소로 이동한다.
5. `NumberLiteral (4)`: `CallExpression`의 param중 첫번째 요소로 이동한다.
6. `NumberLiteral (2)`: `CallExpression`의 param중 두번째 요소로 이동한다.

## Visitor

위에서 node를 순회할 때 기존의 node를 변경한다면 해당 단계에서 추상화를 사용하나, 우리는 node를 방문(visit)하기만 한다.  
이 과정에서 visitor를 사용하는데, visitor는 각 node를 방문할 때 해당 node와 일치하는 함수를 실행하는 객체이다.

이때 어떤 node를 방문했는지 알게 하기 위해서 파라미터로 node와 parent를 넘겨준다.  
그리고 어떤 node에 들어가거나, 나을 때의 행동이 정해져 있으야하므로 `enter, exit`라는 2가지의 함수를 만들어둔다.

```
var visitor = {
    NumberLiteral: {
        enter(node, parent) {},
        exit(node, parent) {}
    },
}
```

# Code generation

이 과정은 AST를 읽고 새로운 코드를 만드는 것이다.  
여기에서는 기존에 있던 AST를 읽고 재귀적으로 순회하면서 코드를 출력하지만, 일부의 경우에는 다른 형태의 AST를 사용해서 선형적으로 코드를 출력하기도 한다.

# 실제로 적용하기

## Tokenizer

```js
function tokenizer(input) {
  // 현재 위치를 가리키는 커서
  let current = 0;

  // 토큰을 저장할 배열
  let tokens = [];

  // input의 길이만큼 current를 증가시키면서 token을 찾음
  while (current < input.length) {
    // 현재 위치의 문자
    let char = input[current];

    // 제일 처음으로 (를 찾음
    if (char === "(") {
      // token을 생성하고 tokens에 추가
      tokens.push({
        type: "paren",
        value: "(",
      });

      // current를 증가시키고 continue
      current++;
      continue;
    }

    // 마찬가지로 )를 찾음
    if (char === ")") {
      tokens.push({
        type: "paren",
        value: ")",
      });

      current++;
      continue;
    }

    // 공백문자를 찾음
    // 다만 공백문자는 코드에서 유의미한 정보가 아니기에 무시한다.
    let WHITESPACE = /\s/;
    if (WHITESPACE.test(char)) {
      current++;
      continue;
    }
  }
}
```
